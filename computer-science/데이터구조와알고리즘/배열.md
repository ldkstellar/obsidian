```cpp
int x = 10; // scalar 
int A[S]; // vector  
int A[5] = {2,4}; // 2 4 0 0 0
int A[5] = {0}; // 0 0 0 0 0 
int A[] = {1,2,3,4,5}; // 1,2,3,4,5
```
### Arrays in Compilers

```cpp
Addr(A[i]) // = L0 + (i-1) * w
		// base Addr ,index, size of Data type 

int A[m][n];

// row major 
Addr([i][j]) // L0 + (i*n +j) * w

// column major
Addr[i][j] // L0 +(j*m +i) * w

// row major
Addr[i][j][k][l] // L0 + [i*d2*d3*d4 + j*d3*d4 + k*d4 + l] * w

// column major
Addr[i][j][k]][l] // L0 + [l *d1 *d2 *d3+ k *d1 *d2 + j*d1 +i] * w
```

### 1. Row-major Mapping

```cpp
->
// [d1][d2][d3][d4]
Addr(A[1][2]) // 200 +[i*d2+j] *2 = 200+6*2

// base Addr,index ,size of data type

Addr[i][j][k] // L0 + [i* d2 * d3 + j * d3  + k] 

Addr[i][j][k][l] // L0 +[i*d2*d3*d4 + j*d3*d4 + k*d4 + l] * w

```

### 2. Column-major Mapping

```cpp
// <-
// d1 d2 d3 d4

Addr([1][2]) // 200 + [2 * d1 + 1]*2

Addr[i][j][k] // L0
Addr[i][j][k]][l] // L0 + [l *d1 *d2 *d3+ k *d1 *d2 + j*d1 +i] * w
```


### Conclusion

4 D -> 3 + 2 + 1
5 D -> 4+3+2+1
n D  -> n-1 + n-2 ...3+2+1 =  n(n-1)/2 = O(n^2)

공통 부분끼리 묶으면 n-1만큼 곱셈을하게 된다. 즉, 시간 복잡도는 n-1이다.

