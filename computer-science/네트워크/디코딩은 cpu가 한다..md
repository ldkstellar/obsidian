조건문 같이 한다.
애플리케이션 단에서한다.파싱함수를 사용한다. 내부는 조건문처럼 구성이 되어있다.
드라이버는 os커널 사이에 연결하는 통로

### 파싱 함수가 사라지지 않는 이유

위와 같은 방법들을 적용하더라도 **완벽하게 파싱 함수가 사라지는 것은 불가능**합니다. 그 이유는 다음과 같습니다.

- **포맷의 다양성**: RISC-V 시스템이 처리해야 할 데이터 포맷은 하나가 아닙니다. AI 모델, 실행 가능한 바이너리, 설정 파일 등 다양한 포맷이 존재합니다. 이러한 다양한 포맷에 대응하기 위해서는 각 포맷에 맞는 최소한의 파싱 로직이 필요합니다.
    
- **메타데이터의 필요성**: 데이터를 전달하더라도 데이터의 크기, 타입, 메모리 배치 정보 등 **메타데이터**를 파싱해야 합니다. 예를 들어, AI 가속기에 전달되는 모델 데이터라 하더라도 가중치와 편향의 크기, 레이어 정보 등을 식별해야 합니다. 이는 결국 파싱의 한 형태입니다.
    
- **디버깅 및 유지보수**: 개발 및 디버깅 과정에서 원본 데이터 포맷을 분석하고 검증하는 작업은 필수적입니다. 이 과정에서 데이터를 읽고 구조를 파악하는 파싱 함수가 사용됩니다.


### 실적인 한계

하지만 이러한 방식은 다음과 같은 현실적인 제약 때문에 일반적인 시스템에서는 구현하기 어렵습니다.

- **유연성 부족**: 입력 데이터의 포맷이 조금이라도 변경되면, 앞단의 시스템 전체를 수정해야 합니다. 이는 시스템의 확장성이나 유연성을 크게 떨어뜨립니다.
    
- **오류 처리의 어려움**: 앞단에서 데이터 전처리 과정 중 오류가 발생하면, RISC-V 시스템은 그 오류를 감지하고 처리할 수 있는 방법이 없습니다. 데이터가 손상된 상태로 전달될 경우 시스템이 오작동하거나 멈출 수 있습니다.
    
- **복잡성의 이전**: 파싱 로직을 RISC-V 시스템에서 제거하더라도, 그 복잡성은 **데이터를 전달하는 앞단의 시스템으로 옮겨갑니다.** 즉, 파싱의 부담을 줄이는 것이 아니라, 단지 다른 곳으로 옮기는 것에 불과합니다.
    

### 결론

입력값을 파싱하는 함수를 아예 만들지 않는 방식은 **특정 목적에 최적화된 하드웨어 시스템**에서 고려할 수 있는 전략입니다. 그러나 **범용적인 운영체제나 소프트웨어**의 경우, 다양한 데이터 포맷과 예외 상황에 대응하기 위해 **파싱 로직은 필수적**입니다. 앞에서 모든 것을 분류하고 가공하는 것은 **파싱 기능을 전담하는 하드웨어 또는 소프트웨어 모듈을 따로 두는 것**으로 볼 수 있습니다.