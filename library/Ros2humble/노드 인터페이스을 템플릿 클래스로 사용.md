모든 Ros노드들은 동등하게 생성되지 않는다.
rclcpp:Node 와 rclcpp_lifecycle::LifecycleNode 클래스들은 상속 트리를 공유하지 않는다.그리고 그것은 로스2개발자들은 컴파일타입에 타입 이슈를 발생 할수 있다. 그들이 Ros node 포인터 아규먼트로 받는 함수를 작성할때

1. shared_ptr로 노드 정보 접근 

```cpp
#include <memory>
#include "rclcpp/rclcpp.hpp"

void node_info(rclcpp::Node::SharedPtr node)
{
  RCLCPP_INFO(node->get_logger(), "Node name: %s", node->get_name());
}

class SimpleNode : public rclcpp::Node
{
public:
  SimpleNode(const std::string & node_name)
  : Node(node_name)
  {
  }
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  auto node = std::make_shared<SimpleNode>("Simple_Node");
  node_info(node);
}
```

2. 명시적 전달 rclcpp::node_interfaces

```cpp
void node_info(std::shared_ptr<rclcpp::node_interfaces::NodeBaseInterface> base_interface,
               std::shared_ptr<rclcpp::node_interfaces::NodeLoggingInterface> logging_interface)
{
  RCLCPP_INFO(logging_interface->get_logger(), "Node name: %s", base_interface->get_name());
}

class SimpleNode : public rclcpp::Node
{
public:
  SimpleNode(const std::string & node_name)
  : Node(node_name)
  {
  }
};

class LifecycleTalker : public rclcpp_lifecycle::LifecycleNode
{
public:
  explicit LifecycleTalker(const std::string & node_name, bool intra_process_comms = false)
  : rclcpp_lifecycle::LifecycleNode(node_name,
      rclcpp::NodeOptions().use_intra_process_comms(intra_process_comms))
  {}
}

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::executors::SingleThreadedExecutor exe;
  auto node = std::make_shared<SimpleNode>("Simple_Node");
  auto lc_node = std::make_shared<LifecycleTalker>("Simple_LifeCycle_Node");
  node_info(node->get_node_base_interface(),node->get_node_logging_interface());
  node_info(lc_node->get_node_base_interface(),lc_node->get_node_logging_interface());
}
```