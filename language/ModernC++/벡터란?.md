- **어떤 자료형**도 넣을 수 있는 동적 배열(heap메모리에 저장이 된다.)
	- 기본 데이터
	- 클래스
	- 포인터
- 그 안에 저장된 모든 요소들이 연속된 메모리 공간에 위치
- 요소 수가 증가함에 따라 자동으로 메모리를 관리해줌
- 어떤 요소에도 임의로 접근가능
	

![[Pasted image 20250505143722.png]]

![[Pasted image 20250505144109.png]]
그냥 reserve로 공간만 잡아주자
초기화 하지 말고

##### 용량과 크기
capacity
- vector에 할당된 요소 공간 수
size
- vector에 실제로 들어 있는 요소수

vector의 용량 늘리기
- vector의 용량을 늘린다
- 용량이 증가해야 하면 새로운 저장 공간을 재할당하고 기존 요소들을 모두 새 공간으로 복사
	거의 두배씩 늘려준다.
	백터 선언후 reserve해주면 컴파일러가 최적화를 해준다. 즉 공간을 크게 잡아준다.

![[Pasted image 20250505151328.png]]
즉, 값을 반환하는 것이 아니라 참조를 반환을 한다.

##### 반복자(iterator)
- vector 요소들을 순회하는데 사용한다.
 - 포인터 값이다.
 - begin 과 end는 iterator를 반환한다.

###### begin() ,end(),rbegin(),rend() 비교

![[Pasted image 20250507101115.png]]
##### 벡터 작동방식
기본적으로 벡터는 이동시 복사를 한다. 그리고 공간이 부족하면 재할당을 사용한다.
이동이나 삭제시 복사를 할때 최적화하는 방법
순서가 중요하지 않는 데이터 구조에서는 맨뒤에 있는 값을 앞으로 메꾸면서 한칸씩 이동하는 것을 방지한다.

##### 두 백터 교환하기

![[Pasted image 20250507103627.png]]
메모리 주소를 바꾼다.

##### 백터의 크기 변경하기
resize();
- vector의 크기를 바꾼다.
- 새 크기가 vector의 기존 크기보다 작으면, 초과분이 제거됨
- 새 크기가 vector의 용량보다 크면 재할당이 일어남

##### vector에서 모든 요소 제거하기
clear();
- vector를 싹 지운다
- 크기 (size)는 0이되고 용량은 변하지 않음

##### 개체 벡터
string 개체는별도의 힙에 데이터가 저장이되며,주소값 + capacity + size =12바이트가 vector에 저장이 된다. 

##### 개체를 직접 보관하는 벡터의 문제점2
값을 그대로 복사한다. 사본을 복사한다는 뜻이다.메모리를 쓴다.

##### 포인터를 저장하는 벡터
```cpp
#include <iostream>

#include <vector>

using namespace std;

class Score {
public:
	Score(int mScore, string mClassName);

private:
	int mScore;
	string mClassName;
};

Score::Score(int mScore, string mClassName)
	: mScore(mScore), mClassName(mClassName) {}

  

int main(int argc, char const *argv[]) {
	
	vector<Score *> scores;
	scores.reserve(2);
	scores.push_back(new Score(30, "C++"));
	scores.push_back(new Score(70, "android"));
for (vector<Score *>::iterator iter; iter != scores.end(); iter++) {
	delete *iter;
}

scores.clear(); // 저장된 포인터 메모리 삭제

return 0;

}
```

모든 요소에 대해 delete를 꼭 호출할 것
- 또한 지운 뒤에 이 포인터들을 계속 사용하면 안됨
