- 중간에 실행을 멈췄다가, 필요할 때 다시 이어서 실행 가능
- 싱글스레드 기반

| **항목**       | **코루틴 (Coroutine)**                  | **스레드 (Thread)**                |
| ------------ | ------------------------------------ | ------------------------------- |
| **실행 방식**    | 협력적 실행 (명시적으로 yield 또는 co_await)     | 선점형 실행 (OS 스케줄러가 자동으로 실행 시점 제어) |
| **동작 위치**    | 주로 **단일 스레드** 내에서 실행됨                | **멀티스레드**, 즉 운영체제 수준에서 병렬 실행 가능 |
| **병렬 처리**    | 진짜 병렬 아님, 동시성은 있으나 CPU 병렬 불가         | 멀티코어를 활용한 **진짜 병렬 처리 가능**       |
| **전환 비용**    | 매우 낮음 (함수 호출 수준)                     | 비교적 높음 (컨텍스트 스위칭 발생)            |
| **상태 저장**    | 함수 상태를 내부적으로 저장해 중단 후 재개 가능          | 스택 기반이므로 상태 저장은 개발자가 직접 관리해야 함  |
| **적합한 작업**   | 비동기 I/O, 이벤트 처리, 상태 머신               | 무거운 연산, 병렬 컴퓨팅, CPU 집약적인 작업     |
| **디버깅 난이도**  | 비교적 어려움 (중단점·재개점 파악 필요)              | 비교적 쉬움 (스택 트레이스가 명확함)           |
| **사용 복잡도**   | 비교적 간단 (구조적 흐름, 낮은 동기화 필요)           | 복잡함 (동기화, 데드락, 경합 등 신경 써야 함)    |
| **에러 전파 방식** | 일반적으로 co_return이나 예외 처리로 전파          | 스레드 안에서 예외 처리 안 하면 전체 프로세스 중단   |
| **언어/환경 지원** | 일부 언어(C++, Python, Kotlin 등)만 명시적 지원 | 거의 모든 언어에서 기본 지원                |