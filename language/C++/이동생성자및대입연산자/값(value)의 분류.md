
### lvalue란?

- 단일 식을 넘어 지속되는 개체
	- 주소가 있음
	- 이름이 있는 변수
	- const 변수
	- 배열 변수
	- 비트 필드 (bit-fields)
	-  공용 구조체(unions)
	- 클래스 멤버
	- 좌측 값 참조(&)로 반환하는 함수 호출
	- 문자열 리터럴
- 결국 지금까지 봐 온 많은 것들

![[Pasted image 20250729141433.png]]

### rvalue란?
- 사용되는 단일 식을 넘어 지속되지 않는 **일시적인 값**
	- 주소가 없는 개체
	- 리터럴(문자열 리터럴 제외)
	- 참조로 반환하지 않는 함수 호출
	- i++와 i-- (++i와 --i는 lvalue들)
	- 기본적으로 지원되든 산술식, 논리식,그리고 비교식
	- 열거형(enum)
	- 람다(lambda)

![[Pasted image 20250729142918.png]]
![[Pasted image 20250729143028.png]]

![[Pasted image 20250729143830.png]]
결론은 복사생성자에서 변환돤 값을 반환하고 반환 값을 복사를해서 결론적으로 2번 복사가 일어나는 매커니즘이다.
**rvalue 참조와 이동 문법으로 해결할수 있다.**

### rvalue 참조(&&)
- c++11이후에 새로 나온 연산자
- 기능상 &연산자와 비슷
- &연산자는 lvalue 참조에 사용
- && 연산자는 rvlaue참조에 사용 임시 주소를 전달한다. 소유권을 전달하는 것이다.

### std::move()
- rvalue 참조를 반환
- lvalue를 rvalue로 변환

### 이동 생성자
- 다른 개체 멤버 변수들의 소유권을 가져옴
- 복사 생성자와 달리, 메모리 재할당을 하지 않음
- 복사 생성자보다 빠름
- 약간 얕은 복사와 비슷

### rvalue 최적화

- 이동 생성자와 이동 대입 연산자
	- 아직 유효
- 포인터 대신 개체 자체를 반환하는 함수
	- 함수에서 rvalue를 반환하는 것은 실제 매우 느림
	- 반환 값 최적화(Return Value Optimization)라고 하는 컴파일러 최적화를 깨뜨림 원리는 stack에 만드는 최적화를 한다.
- 베스트 프랙티스
	-  기본적으로 그냥 개체를 반환
	- 더 빨라진다고 입증된 경우에만 함수가 rvalue를 반환하도록 바꾸자

### STL  컨테이너용 이동 문법
- C+11 이후로 , STL 컨테이너에 이동 생성자와 이동 대입이 생김.
- 그래서, 그것들을 따로 구현할 필요가 없음
