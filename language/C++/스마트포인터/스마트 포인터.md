- unique_ptr
- shared_ptr
- weak_ptr

### uninque_ptr
포인터가 하나밖에 없다 소유자가

- 포인터(원시 포인터라 부르자)를 단독으로 소유
- 원시 포인터는 누구하고도 공유되지 않음
- 따라서 복사나 대입 불가
- unique_ptr가 범위(scope)를 벗어날 때, 원시 포인터는 지워짐 (delete)

### unique 포인터가 쓰이기 좋은 곳
![[Pasted image 20250623155110.png]]
![[Pasted image 20250623155602.png]]

### 문제: 원시 포인터 공유
![[Pasted image 20250626171345.png]]
![[Pasted image 20250626171727.png]]

### C++14 이후 해결책

```cpp
std::unique_ptr<MyVector> myVector2 = std::make_unique<MyVector>(10.f, 30.f);
myVector2->print();
```

### std::make_unique()가 무슨 일을 할까?
- 주어진 매개변수와 자료형으로 new 키워드를 호출해 줌
- 따라서 원시 포인터와 같음
- 둘 이상의 std::unique_ptr가 원시 포인터를 공유할 수 없도록 막는게 전부

![[Pasted image 20250626172502.png]]
### 유니크 포인터 만들기

```cpp
// C+11(C+14을 쓸 수 없는 경우)
std::unique_ptr<Vector> vector(new Vector(10.f,30.f));
std::unique_ptr<Vector[]>vectors(new Vecotr[20]);

// C+14 (이걸 쓰자)
std::unique_ptr<Vector> vector = std::make_unique<vector>(10.f,30.f);
std::unique_ptr<Vector[]> vectors = std::make_unique<Vector[]>(20);
```

### reset
![[Pasted image 20250626175237.png]]
첫번째는 리셋해주면 첫번째 저장한 포인터 메모리해제하고 다시 새로운 백터 생성하고 저장
2번째는 아에 포인터에 nullptr을 넣어 주는 것이다.

![[Pasted image 20250626175556.png]]

### 유니크 포인터 재설정하기

- 포인터를 교체한다
- std::unique_ptr가 재설정될 때, 소유하고 있던 원시 포인터는 자동으로 소멸됨

```cpp
myVector.reset(new Vector(20.f,40.f));
myVector.reset();
```

### 포인터 가져오기
- 원시 포인터를 반환한다.
```cpp
Vector* ptr = myVector.get();
```

### release()
```cpp
int main(){
std::unique_ptr<Vector>vector = std::make_unique<Vector>(10.f,30.f);
Vector* vectorptr = vector.release();
}
```
소유권을 넘겨주는 메커니즘이다.

- 원시 포인터에 대한 소유권을 박탈하고 원시 포인터를 반환한다.
- release() 호출 후 get()을 호출하면 nullptr이 반환됨

```cpp
Vector* vectorPtr = vector.release();
Vector* vectorPtr2 = vector.get()//nullptr
```

### 유니크 포인터 소유권 이전하기
```cpp
#include <memory>

  

#include "myVector.h"

int main(int argc, char const *argv[]) {

std::unique_ptr<MyVector> vector = std::make_unique<MyVector>(10.f, 30.f);

std::unique_ptr<MyVector> anotherVector(std::move(vector));

return 0;

}
```
