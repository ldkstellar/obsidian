- unique_ptr
- shared_ptr
- weak_ptr

### uninque_ptr
포인터가 하나밖에 없다 소유자가

- 포인터(원시 포인터라 부르자)를 단독으로 소유
- 원시 포인터는 누구하고도 공유되지 않음
- 따라서 복사나 대입 불가
- unique_ptr가 범위(scope)를 벗어날 때, 원시 포인터는 지워짐 (delete)

### unique 포인터가 쓰이기 좋은 곳
![[Pasted image 20250623155110.png]]
![[Pasted image 20250623155602.png]]

### 문제: 원시 포인터 공유
![[Pasted image 20250626171345.png]]
![[Pasted image 20250626171727.png]]

### C++14 이후 해결책

```cpp
std::unique_ptr<MyVector> myVector2 = std::make_unique<MyVector>(10.f, 30.f);
myVector2->print();
```

### std::make_unique()가 무슨 일을 할까?
- 주어진 매개변수와 자료형으로 new 키워드를 호출해 줌
- 따라서 원시 포인터와 같음
- 둘 이상의 std::unique_ptr가 원시 포인터를 공유할 수 없도록 막는게 전부

![[Pasted image 20250626172502.png]]
### 유니크 포인터 만들기

```cpp
// C+11(C+14을 쓸 수 없는 경우)
std::unique_ptr<Vector> vector(new Vector(10.f,30.f));
std::unique_ptr<Vector[]>vectors(new Vecotr[20]);

// C+14 (이걸 쓰자)
std::unique_ptr<Vector> vector = std::make_unique<vector>(10.f,30.f);
std::unique_ptr<Vector[]> vectors = std::make_unique<Vector[]>(20);
```

### reset
![[Pasted image 20250626175237.png]]
첫번째는 리셋해주면 첫번째 저장한 포인터 메모리해제하고 다시 새로운 백터 생성하고 저장
2번째는 아에 포인터에 nullptr을 넣어 주는 것이다.

![[Pasted image 20250626175556.png]]

### 유니크 포인터 재설정하기

- 포인터를 교체한다
- std::unique_ptr가 재설정될 때, 소유하고 있던 원시 포인터는 자동으로 소멸됨

```cpp
myVector.reset(new Vector(20.f,40.f));
myVector.reset();
```

### 포인터 가져오기
- 원시 포인터를 반환한다.
```cpp
Vector* ptr = myVector.get();
```

### release()

```cpp
int main(){
std::unique_ptr<Vector>vector = std::make_unique<Vector>(10.f,30.f);
Vector* vectorptr = vector.release();
}
```

소유권을 넘겨주는 메커니즘이다.

- 원시 포인터에 대한 소유권을 박탈하고 원시 포인터를 반환한다.
- release() 호출 후 get()을 호출하면 nullptr이 반환됨

```cpp
Vector* vectorPtr = vector.release();
Vector* vectorPtr2 = vector.get()//nullptr
```

### 유니크 포인터 소유권 이전하기

```cpp
#include <memory>
#include "myVector.h"

int main(int argc, char const *argv[]) {

std::unique_ptr<MyVector> vector = std::make_unique<MyVector>(10.f, 30.f);

std::unique_ptr<MyVector> anotherVector(std::move(vector));// move를 사용하여 이동시킨다.

return 0;

}
```

### const 유니크 포인터는 어떨까?

```cpp
std::unique_ptr<MyVector> vector = std::make_unique<MyVector>(10.f, 30.f);

std::unique_ptr<MyVector> anotherVector(std::move(vector)); // 컴파일 에러
```

### 소유권 이전하기

- std::unique_ptr는 소유한 원시 포인터를 아무하고도 공유하지 않음
- 즉, 주소 복사를 하지 않는다는 뜻이다
- 대신, 소유권을 다른 std::unique_ptr로 옮길 수 있음
- 예외: const std::unique_ptr

### std::move()

-  개체 A의 모든 멤버를 포기하고 그 소유권을 B에게 주는 방법
- 메모리 할당과 해제가 일어나지 않음
- 간단하게,A에 있는 모든 포인터를 B에게 대입하고 A에게는 nullptr를 넣는다고 생각하자
- 나는 멤버 변수를 옮기고 있다
- 이게 어떻게 도는지 알려면 r-value와 이동(move) 생성자를 배워야됨

![[Pasted image 20250701225518.png]]
move를 안넣으면 백터의 요소를 삭제할때  같은 포인터의 메모리를 두번 해제하게 된다. move를 넣어주는 순간 알몸 포인터를 전달한다.

### std::unique_ptr의 비밀 공개
![[Pasted image 20250702160640.png]]
c++ 스펙상 delete null은 아무이상 없다

### std::unique_ptr 베스트 프랙티스
- 이제 다들 이걸 씀
- 직접 메모리 관리하는 것만큼 빠름
-  RAII(Resource Acquisition is Initialization) 원칙에 잘 들어맞음
	- 자원할당은 개체의 수명과 관련되어 있음
	- 생성자에서 new 그리고 소멸자에서 delete
	- std::unique_ptr 멤버 변수가 이걸해 줌
	- 실수하기 어려움
	- 모든 곳에 쓰자!
	- 만약 커스소멸자를 사용하면 커스텀 소멸자를 호출한다. 커스텀 소멸자에 메모리 해제가 없으면 메모리 누수가 난다.
### Shared pointer
### 자동 메모리 관리

- 주로 쓰는 두가지 기법
	- 가비지 컬렉션, Java와 c#에서 지원
	- 참조 카운팅,Swift와 애플 Objective-C에서 지원