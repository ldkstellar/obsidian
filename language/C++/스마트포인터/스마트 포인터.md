- unique_ptr
- shared_ptr
- weak_ptr

### uninque_ptr
포인터가 하나밖에 없다 소유자가

- 포인터(원시 포인터라 부르자)를 단독으로 소유
- 원시 포인터는 누구하고도 공유되지 않음
- 따라서 복사나 대입 불가
- unique_ptr가 범위(scope)를 벗어날 때, 원시 포인터는 지워짐 (delete)

### unique 포인터가 쓰이기 좋은 곳
![[Pasted image 20250623155110.png]]
![[Pasted image 20250623155602.png]]

### 문제: 원시 포인터 공유
![[Pasted image 20250626171345.png]]
![[Pasted image 20250626171727.png]]

### C++14 이후 해결책

```cpp
std::unique_ptr<MyVector> myVector2 = std::make_unique<MyVector>(10.f, 30.f);
myVector2->print();
```

### std::make_unique()가 무슨 일을 할까?
- 주어진 매개변수와 자료형으로 new 키워드를 호출해 줌
- 따라서 원시 포인터와 같음
- 둘 이상의 std::unique_ptr가 원시 포인터를 공유할 수 없도록 막는게 전부

![[Pasted image 20250626172502.png]]
### 유니크 포인터 만들기

```cpp
// C+11(C+14을 쓸 수 없는 경우)
std::unique_ptr<Vector> vector(new Vector(10.f,30.f));
std::unique_ptr<Vector[]>vectors(new Vecotr[20]);

// C+14 (이걸 쓰자)
std::unique_ptr<Vector> vector = std::make_unique<vector>(10.f,30.f);
std::unique_ptr<Vector[]> vectors = std::make_unique<Vector[]>(20);
```

### reset
![[Pasted image 20250626175237.png]]
첫번째는 리셋해주면 첫번째 저장한 포인터 메모리해제하고 다시 새로운 백터 생성하고 저장
2번째는 아에 포인터에 nullptr을 넣어 주는 것이다.

![[Pasted image 20250626175556.png]]

### 유니크 포인터 재설정하기

- 포인터를 교체한다
- std::unique_ptr가 재설정될 때, 소유하고 있던 원시 포인터는 자동으로 소멸됨

```cpp
myVector.reset(new Vector(20.f,40.f));
myVector.reset();
```

### 포인터 가져오기
- 원시 포인터를 반환한다.
```cpp
Vector* ptr = myVector.get();
```

### release()

```cpp
int main(){
std::unique_ptr<Vector>vector = std::make_unique<Vector>(10.f,30.f);
Vector* vectorptr = vector.release();
}
```

소유권을 넘겨주는 메커니즘이다.

- 원시 포인터에 대한 소유권을 박탈하고 원시 포인터를 반환한다.
- release() 호출 후 get()을 호출하면 nullptr이 반환됨

```cpp
Vector* vectorPtr = vector.release();
Vector* vectorPtr2 = vector.get()//nullptr
```

### 유니크 포인터 소유권 이전하기

```cpp
#include <memory>
#include "myVector.h"

int main(int argc, char const *argv[]) {

std::unique_ptr<MyVector> vector = std::make_unique<MyVector>(10.f, 30.f);

std::unique_ptr<MyVector> anotherVector(std::move(vector));// move를 사용하여 이동시킨다.

return 0;

}
```

### const 유니크 포인터는 어떨까?

```cpp
std::unique_ptr<MyVector> vector = std::make_unique<MyVector>(10.f, 30.f);

std::unique_ptr<MyVector> anotherVector(std::move(vector)); // 컴파일 에러
```

### 소유권 이전하기

- std::unique_ptr는 소유한 원시 포인터를 아무하고도 공유하지 않음
- 즉, 주소 복사를 하지 않는다는 뜻이다
- 대신, 소유권을 다른 std::unique_ptr로 옮길 수 있음
- 예외: const std::unique_ptr

### std::move()

-  개체 A의 모든 멤버를 포기하고 그 소유권을 B에게 주는 방법
- 메모리 할당과 해제가 일어나지 않음
- 간단하게,A에 있는 모든 포인터를 B에게 대입하고 A에게는 nullptr를 넣는다고 생각하자
- 나는 멤버 변수를 옮기고 있다
- 이게 어떻게 도는지 알려면 r-value와 이동(move) 생성자를 배워야됨

![[Pasted image 20250701225518.png]]
move를 안 넣으면 백터의 요소를 삭제할때  같은 포인터의 메모리를 두번 해제하게 된다. move를 넣어주는 순간 알몸 포인터를 전달한다.

### std::unique_ptr의 비밀 공개
![[Pasted image 20250702160640.png]]
c++ 스펙상 delete null은 아무이상 없다

### std::unique_ptr 베스트 프랙티스
- 이제 다들 이걸 씀
- 직접 메모리 관리하는 것만큼 빠름
-  RAII(Resource Acquisition is Initialization) 원칙에 잘 들어맞음
	- 자원할당은 개체의 수명과 관련되어 있음
	- 생성자에서 new 그리고 소멸자에서 delete
	- std::unique_ptr 멤버 변수가 이걸해 줌
	- 실수하기 어려움
	- 모든 곳에 쓰자!
	- 만약 커스소멸자를 사용하면 커스텀 소멸자를 호출한다. 커스텀 소멸자에 메모리 해제가 없으면 메모리 누수가 난다.
### Shared pointer
### 자동 메모리 관리

- 주로 쓰는 두가지 기법
	- 가비지 컬렉션, Java와 c#에서 지원
	- 참조 카운팅,Swift와 애플 Objective-C에서 지원

### 가비지 컬렉션
- 보통 트레이싱 가비지 컬렉션(Tracing Garbage Collection)을 의미
- 메모리 누수를 막으려는 시도
- 주기적으로 컬렉션 실행
- 충분한 여유 메모리가 없을 때 컬랙션이 실행됨
	- 스케줄에 따라 또는 수동으로도 실행가능
- 매 주기마다, GC는 루트("root")를 확인함:
	- 전역변수
	- 스택
	- 레지스터
- 힙에 있는 개체에 루트를 통해 접근할 수 있는지 판단
- 접근할 수 없다면, 가비지로 간주해서 해제

### 가비지 컬렉션의 문제점
- 사용되지 않는 메모리를 즉시 정리하지 않음
-  GC가 메모리를 해제해야 하는지 판단하는 동안 애플리케이션이 멈추거나 버벅일 수 있음


### 참조 카운팅
- 가비지  컬렉션 처럼, 개체에 대한 참조가 없을 때 개체가 해제됨
- 언제든지 참조 횟수를 활용해서 특정 개체가 몇번이나 참조되고 있는지 판단 가능
- 어떤 개체 A를 다른개체 B가 참조할 때 횟수가 늘어남
- B가 참조를 그만둘 때 횟수 줄어듦 예)B가 범위(scope)를 벗어나는 경우

![[Pasted image 20250707175510.png]]

![[Pasted image 20250707175808.png]]

### 수동 참조 카운팅
- std::shared_ptr는 이걸 자동으로 해줌

### 강한(strong) 참조
- 강한 참조란 개체 A가 개체B를 참조할 때, 개체 B는 절대 소멸되지 않음을 의미
- 강한 참조의 수를 저장하기 위해 강한 참조 카운트를 사용
- 일반적으로 새 인스턴스, 즉 개체에 대한 참조를 만들 때 강한 참조 횟수가 늘어남
- 강한 참조 횟수가 0이 될 때 해당 개체는 소멸됨

### 참조 카운팅의 문제점
- 참조 횟수는 너무 자주 바뀜
	- 멀티 쓰레드 환경에서 안전하려면,Lock이나 원자적(atomic) 연산이 필요
	- ++mRefCount보다 확연히 느림
- 순환(circular) 참조
	- 개체 A가 개체 B를 참조
	- 개체 B가 개체 A를 참조
	- 절대 해제 되지 않음!
	- c++ 해결책이 있음
	
![[Pasted image 20250707180948.png]]
![[Pasted image 20250707182102.png]]

### std::shared_ptr
-  두개의 포인터를 소유
	- 데이터(원시 포인터)를 가리키는 포인터
	- 제어 블록을 가리키는 포인터
- std::unique_ptr와 달리 , 포인터를 다른 std::shared_ptr와 공유할수 있다.
- 참조 카운팅 기반
- 원시 포인터는 어떠한 shared_ptr에게도 참조되지 않을 때 소멸됨
- 해당 포인터가 스코프를 벗어나거나 reset() 또는 nullptr로 설정되면 use_count가 1 감소합니다.

### 포인터 재설정하기
```cpp
void reset();
```
- 원시 포인터를 해제 한다
- 참조 카운트가 1 줄어듦
- nullptr를 대입하는 것과 같음

![[Pasted image 20250708165148.png]]
참조로 가져와서 sharedpointer count를 증가를 막는다.
![[Pasted image 20250708165359.png]]

### Weak_ptr

- 약한 참조는 원시 포인터 해제에 영향을 끼치지 않음
- 약한 참조 카운트는 약한 참조의 수를 저장히는 데 사용됨
- 약한 참조로 참조되는 개체는 강한 참조 카운트가 0이 될 때 소멸됨
- 순환 참조 문제의 해결책
