###  1. 멤버변수 초기화
- c++은 기본적으로 멤버변수를 초기화를 해주지 않는다. 따라서 다음과 같이 초기화 해줘야한다. 할당은 말그대로 초기화한후 할당이다. 더 속도가 느리겠지?
- c++은 기본적으로 컴파일러가 기본생성자와 기본소멸자를 만들어준다. but 생성자를 정의를 하면 만들어주지 않는다.
- 기본생성자란 파라미터가 없는 생성자를 말한다.
- 혼동하지 말아야 할것 기본적으로 초기화는 해주지 않는다. 생성자는 자동으로 만들어준다. 별개이다.

```cpp
Vector::Vector() : mX(0), mY(0)
{

}
```
 - 참고 c에서 사용하는 방법
 ```c
struct Point {
	int a;
	int b;
	
}

int main(){
Point point = {1,2};
// 동적 할당
Point* ptr;
void *heap = malloc(sizeof(Point));
ptr = (Point *)heap;
free(ptr);

}


```

 객체를 초기화 하는 방법
```cpp
Vector::Vector() : mX(0), mY(0) // 이렇게 초기화사용한다.
{// 여기 메커니즘은 초기화후 다음의 메커니즘

}

```

### 둘 중 컴파일 안 되는 코드는?

```cpp
class Vector {
	private:
		int mX;
		int mY;

};

void Foo(){
	Vector a; // 컴파일 에러x 
	Vector b(10,2);// 컴파일 에러
}

```

이유가 뭘까?
클래스에 생성자 함수가 없으면 c++은 기본 생성자를 생성한다.기본생성자는 쓰레기 값이 들어갈 수있다.
배열은 멤버 변수를 초기화 하지 못한다.

### 2.생성자 오버로딩(Overloading)
- 생성자 오버로딩(Overloading)
	-  같은 이름
	-  인자의 개수나 자료형은 다름
	-  기본 
	-  매개 변수를 가지는 생성자

### 3.Const란?
- 바꿀 수 없는 것을 말한다.
```cpp
// const 변수
const int LINE_SIZE = 20;

// const 메서드 . 해당 개체 안의 어떤 것도 바꾸지 않음
// 멤버 변수
int GetX() const; // 즉 멤버변수내에 있는 것을 수정하지 못한다.

```

### 4.구조체
c에서 구조체는 함수를 넣을 수 없다. 하지만 c++에서는 class와 동일하다.
```cpp
// 기본 접근 권한 public
struct Vector{
	int x;
	int y;
};
// private
class Vector{
int x;
int y;
}
```

컴퓨터는 이 둘을 구분할까?
구분을 못한다.
struct단도 변수들 그룹을 지어 놓은 것이기때문에 모른다.
어셈블리어 단에서 거의 차이없이 돈다. 컴파일러단에서는 구분한다
priviate 와 public을 구분 하기 위해서

### 추가본  클래스의 함수가 컴파일러에서 인식하는 방법
예를 들어 개체 b의 멤버 변수 func가 있다고하자
```cpp
b::func();// cpp코드
void func(*b this); //컴파일러가 생각하는 모습

MinimalPublisher node;//cpp 코드
node.timer_callback();
MinimalPublisher::timer_callback(&node);//컴파일러가 생각하는 모습
```


### 5. 복사 생성자

중요 면접에서 많이 나옴!
다른 개체를 이용하여 새로운 개체를 초기화
- 같은 크기, 같은 데이터
코드에 복사 생성자가 없는 경우, 컴파일러가 암시적 복사 생성자를 자동으로 생성한다.

암시적 복사 생성자
 - 암시적 복사 생성자는 `얕은 복사(shallow copy)`를 수행한다
 클래스안에 포인터값이 있을 경우는 어떻게 되는가?

사용자가 만든 복사 생성자
 - 클래스 안에서 동적으로 메모리를 할당하고 있다면? 얕은 복사가 위험할 가능성이 매우 높음
 - 직접 복사 생성자를 만들어서 `깊은 복사(deep copy)`를 할 것
 
```cpp
 Vector(Vecotr &rhs);
 Vector::Vector(const Vector& other)
: mX(other.mX), mY(other.mY) {} // 사용자 정의의 복사 생성자
```
### 6. 함수 오버로딩 매칭하기
- 오버로딩 된 함수 중에 어떤 함수를 호출해야 하는지 판단하는 과정
- 리턴값은 상관이 없다 오로지 함수 파라미터 타입이 달라야 한다.

```cpp
// 반환형은 상관이 없다.

void Print(int score); //OK
void Print(const char* name); //OK
void Print(float gpa, const char* name);// OK
int Print(int score); // 컴파일 에러
int Print(float gpa);// OK
```

함수 아큐먼트 int형은 float로 자동 형변환이 가능하다. 컴파일러 경고가 나올수도 있다.

![[Pasted image 20250216162938.png]]

### 7.  연산자 오버로딩
 -  함수처럼 작동하는 부호
 
```cpp
int result = num1 + num2;
if(num1 < num2){}
if(IsNumber || IsAlphabet()){}
num++;
num += 1;
```

- C++에서는 프로그래머가 연산자를 오버로딩할 수 있음

	단항 연산자 
	- 함수로 생각하면 아규먼트가 한개 즉, 할당할 주소가 아규먼트라고 보면된다. 할당할 주소에 값을 바로 넣는다.

	![[Pasted image 20250219001759.png]]

	이항 연산자
	-  함수로 생각하면 아규먼트가 두개 즉, 할당할 주소와  값이있는 아규먼트라고 보면 된다. 
	
	![[Pasted image 20250219002957.png]]
	-  += 작동원리는 기존 값을 레지스터에 저장하고 cpu에서 연산하고 다시 할당 되는 원리이다.
	- C와 Java는 연산자 오버로딩을 지원하지 않는다.
	- 부호는 같지만 여러가지 연산이 가능
	``` cpp
	int1 = int1+int2;
	float1 = float1 + float2;
	name = firstName + lastName;
	```
	
	- 연산자는 오버로딩 하는 방법은 2가지이다.
		- 멤버함수
		- 멤버 아닌 함수

![[Pasted image 20250228125648.png]]

### 8. friend 키워드 

- 클래스 정의 안에 friend 키워드를 사용 가능
	- 다른 클래스나 함수가 나의 private 또는 protected 멤버에 접근 할수 있게 허용
	- friend 함수는 멤버 함수가 아님
	- 하지만 다른 클래스의 private 멤버에 접근할 수 있음

```cpp

// X.h
class X{
	friend class Y;// Y야 내 멤버 변수 접근 가능해
	private:
		int mPrivateInt;
		
};

// Y.h
#include "x.h"

class Y{
public:
	void Foo(X &x);
};

void Y::Foo(X& x){
	x.mPrivateInt += 10; // OK
}
```

전역 함수로도 사용가능 하다.
![[Pasted image 20250302154133.png]]

### 연산자 오버로딩에 필요한 friend 함수
-  friend 함수는 멤버 함수가 아님
-  하지만 다른 클래스의 private 멤버에 접근할 수 있음.
### 클래스에 딸려오는 기본 함수들
-  매개 변수 없는 생성자
-  복사생성자
- 소멸자
- 대입(=) 연산자

### 기본함수를 "지우는" 법
1. 다른 생성자를 정의한다. 그러면 기본 생성자는 지워진다.
2. private로 함수를 정의한다.

### 상속이란?
- 다른 클래스의 특성들을 내려 받음
	-  베이스(base) 클래스
	-  파생(derives) 클래스
- 파생 클래스의 개체는 다음의 것들을 가짐
	- 베이스 클래스의 멤버 변수
	- 베이스 클래스의 멤버 메서드
	- 자신의 생성자와 소멸자
- 파생 클래스는 멤버 변수 및 메서드 추가가능

	파생 클래스를 정의하는 법
	
```cpp
class Cat:public Animal{};
class Honda:private Car{};
class AndroidPhone:protected Phone{};
```
![[Pasted image 20250313164012.png]]
### 상속 접근 종류
public이면 그대로 protected  클래스내에서만 접근가능 
private 접근 불가능 

클래스는 부모 클래스부터 메모리에 할당된다. 그 이후로 순서대로
부모클래스는 자식클래스 원칙적으로 접근 불가능
자식클래스는 부모클래스에 선택적 접근 가능 


### 생성자 호출 순서

- 베이스 클래스의 생성자가 먼저 호출됨 
	- 명시적 또는 암시적으로
- 그 다음으로 파생 클래스의 생성자가 호출 됨
- 부모 클래스의 특정 생성자를 호출 할 때는 초기화 리스트를 사용해야함

![[Pasted image 20250320132328.png]]

### 자식 클래스에서 부모 클래스 생성자 호출하기
그냥 자식 생성자에서 호출하면 된다.

```cpp

class Child : public Parent {
public:
    // 자식 생성자에서 부모 생성자 호출
    Child(int x, int y) : Parent(x) {
        cout << "Child 생성자: " << y << endl;

    }
};
```
### 자식개체 지우기
여기서 자식 개체가 먼저 지워지고 부모 개체가 지워진다.
그리고 delete가 실행이 되면 소멸자가 실행이 된다. 자식부터 -> 부모형태로 변화한다.
부모 클래스에서 

###  소멸자 호출 순서
-  생성자 호출순서와 정반대
-  파생 클래스 소멸자의 마지막에서 베이스 클래스의 소멸자가 자동적으로 호출됨

### 다형성(Polymorphism) 여러가지 모습으로 변한다.

멤버 함수의 메모리
 -  멤버 함수도 메모리 어딘가에 위치해 있음
 - 그런데 각 개체마다 멤버 함수의 메모리가 잡혀 있을까?
	 myCat->GetName();
	 yourCat->GetName();
	 이 둘의 동작은 완전히 일치
- 그 대신 각 멤버 함수는 컴파일 시에 딱 한 번만 메모리에 "할당"됨
	- 저수준에서는 멤버함수는 전역 함수와 그다지 다르지 않음.

![[Pasted image 20250324210607.png]]
### 함수 오버라이딩
- 속이 바뀌는것 **가상함수**를 사용한다.
- 부모포인터로 자식의 가상함수포인터로 호출시 사용한다. 물론 부모 메서드는 호출가능하다. 

### 함수 오버로딩
 - 겉 알맹이가 바뀌는것 즉 리턴값 파라미터들이 바뀐다.

![[Pasted image 20250324211151.png]]

### 정적 바인딩 - 멤버 변수
타입 무늬따라 간다.
부모 자식의 메모리리의 위치를 구분한다. 부모에 자식포인터가 있다.
![[Pasted image 20250326123239.png]]

결론은 어느클래스에 주소를 저장할거냐가 핵심이다.
![[Pasted image 20250326123730.png]]
해당 클래스 주소로 call 부른다.

### 상속관계 동적 바인딩(오버라이딩) 속이 다르다.

```cpp
Animal* yourCat = new Cat();
yourCat->speak();// 오버라이딩 런타임에서 사용 animal 클래스의 가상 테이블 포인터를 따라 함수를 호츌
```
### Java는 모든 것이 기본적으로 가상함수
java 프로그래머는 final 키워드를 사용가능함 이걸 까먹으면 java프로그래머는 
final 키워드를 쓸 수 있음 (비 가상함수보다 느리다.) 컴파일러

### c++에서는 virtual 키워드를 생략하면 정말 x판 난다
- 동적 바인딩 / 늦은 바인딩
- 이를 위해 가상 테이블이 생성된다. 가상함수 테이블은 컴파일타임에 가상함수포인터가 생성이된다. 그리고 호출하면 가상함수 테이블에서 가상함수 포인터에서 찾는다.
### 클래스마다 vs 개체마다 ?			
클래스마다 있다.virtual로 선언이 된 곳
그리고 가상테이블에 부모테이블에 있다. 찾고 함수 호출
이는 타입이 부모클래스이며 자식클래스 메서드를  호출 하고 싶을 때 사용한다.
부모가 자식을 관리한다는 의미를 사용한다.정적할당에서는 참조타입이나 포인터를 사용하여 부모클래스타입 포인터로 자식 주소 할당 받는다.
### 가상함수
- 자식 클래스의 멤버 함수가 언제나 호출됨
	- 부모의 포인터 또는 참조를 사용 중이더라도
- 동적(dynamic)바인딩 / 늦은(late) 바인딩
	- 실행 중에 어떤 함수를 호출할지 결정한다
	- 당연히 정적 바인딩보다 느림
- 이를 위해 가상 테이블이 생성됨
	- 모든 가상 멤버함수의 주소를 포함
	- Q:클래스 마다 하나 vs 개체마다 하나?
		- 클래스마다
	- 개체를 생성할 때, 해당 클래스의 가상 테이블 주소가 함께 저장됨

![[Pasted image 20250402102959.png]]

![[Pasted image 20250402103224.png]]
부모가 가상소멸자이면 자식도 가상소멸자이다. 그래도 혹시 모르니 넣어준다.

![[Pasted image 20250402104142.png]]
그러면 부모클래스에서 소멸하면 자식도 소멸된다.
### 가상함수에 대해 한가지 유의점
- 멤버함수의 가상성은 상속됨
- 베이스 클래스에서 가상으로 선언된 멤버함수가 있다면

### 그래서 다형성이 뭐라고요?(한국말로 설명해보세요)

Answer: 여러형태
결론 다형성 부모클래스내에서 여러가지 종류의 자식클래스의 배열을 사용하기 좋다.

### 다중 상속

##### 어느 부모의 생성자가 먼저 호출이 될까?
- 파생 클래스에서 등장한 부모 클래스 순서대로
- 초기화 리스트의 순서는 상관 없음
##### 클래스 상속한 순서대로 생성자가 호출이 된다.
-  Java에서처럼 super()를 왜 쓸수 없지?
- 다중 상속이 가능하기 때문이다.

##### 다이아몬드 문제
- 다이아몬드 부분 클래스의 부모 클래스에 virtual 키워드를 붙인다.
- 다중 상속을 최대한 쓰지 말기! 대신 **인터페이스**를 사용할 것
- 인터페이스는 부모클래스에서 정의x 선언만 가능 

### 추상(abstract) 클래스

##### 순수(pure) 가상함수
- 구현체가 없는 멤버 함수(멤버 사용은 가능은 한다.)
- 파생 클래스가 구현해야 함
``` cpp
class Animal{
public:
	virtual void speak() = 0;
private:
	int mAge;
};

```
##### 추상 클래스

- 순수 가상함수를 가지고 있는 베이스 클래스를 추상 클래스라 함
	- 추상 클래스에서 개체를 만들 수없음
	- 추상 클래스를 포인터나 참조형으로는 사용가능 
