##### 암시적(Implicit) 캐스팅

- 컴파일러가 형을 변환해 줌
- 단, 형 변환이 허용되고
- 프로그래머가 명시적으로 형 변환을 안 할 경우
그냥 더 큰 비트수를 가진 것으로 옮 길수 있다고 알자
##### 명시적(Explicit) 캐스팅

- 프로그래머가 형 변환을 위한 코드를 직접 작성
- c++ 캐스팅
	1.  static_cast
	2.  const_cast
	3. dynamic_cast
	4. reinterpret_cast
	
- 뭐 이렇게 많을까? 

##### C 스타일 캐스팅
- C++ 스타일 4개의 캐스팅 중 하나를 함
	- 뭔가 명확하지 못함
- 명백한 실수를 컴파일러가 캐치하지 못함
	- c++ 캐스팅이 이런 문제를 해결
	- 그러나 기계는 c vs c++를 구분하지 않음
	- 기계는 c에 있는 정도만 안다.
	
	![[Pasted image 20250410125942.png]]
1. 값
	- 두 숫자 형 간의 변환
		- 값을 유지(단, 반올림 오차는 제외)
		- 이진수 표기는 달라질 수 있음

2. 개체 포인터
	-  변수형 체크 후 베이스 클래스를 파생 클래스로 변환
	-  컴파일 시에만 형 체크 가능
	-  실행 도중 여전히 크래시가 날 수 있음

``` cpp

Animal* myPet = new Cat(2,"Coco");

Cat* myCat = static_cast<Cat*>(myPet); // OK

Dog* myDog = static_cast<Dog*>(mypet); // 컴파일 시에만 형체크가능 실행 도중 여전히 크래시 날 수 있음. dog 클래스의 멤버를 가지고 있지 않기 때문에
```

![[Pasted image 20250410132507.png]]
![[Pasted image 20250410132720.png]]
![[Pasted image 20250414123830.png]]

이진수 표기가 달라지지 않는다.

| **숫자** | **2진수**  | **2의 보수 (내부 저장)** |
| ------ | -------- | ----------------- |
| 5      | 00000101 | 그대로 저장            |
| -5     | 11111011 | 2의 보수로 저장         |
만약 int -5를 unsigned int로 바꾸면 엄청큰 값으로 바뀌겠지 이진수 표기는 안바뀌니까

##### const_cast
- const_cast로 형을 바꿀 수 없음
- const 또는 volatile 애트리뷰트를 제거할 때 사용한다.

![[Pasted image 20250416154558.png]]

const_cast 사용할 때는?
- 써드파티 라이브러리가 const를 제대로 사용하지 않을 때

![[Pasted image 20250416154856.png]]

##### Dynamic_cast
![[Pasted image 20250416155507.png]]
- 실행 중에 형을 판단
- 포인터 또는 참조 형을 캐스팅할 때만 쓸 수 있음
- 호환되지 않는 자식형으로 캐스팅 하려 하면 NULL을 반환
	- 따라서,dynamic_cast가 static_cast보다 안전함 
	
	![[Pasted image 20250416160319.png]]
	그러나 이걸 쓰려면 컴파일중에 RTTI를 켜야함 안키면 static 캐스트랑 똑같이 작동함. 예외처리도 마찬가지 끄는 것 성능 중요한 업계

##### 캐스팅 규칙 
제일 안전한것 -> 가장 위험한 것
1. 기본적으로 static_cast를 쓸 것
2. reinterpret_cast를 쓸 것
3. 내가 변경 권한이 없는 외부 라이브러리를 호출할 때만 const_cast를 쓸 것
