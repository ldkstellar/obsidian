- const를 쓰는 이유?
	- 멤버 변수의 값이 바뀌는 것을 방지
	- 최대한 많은 곳에 const를 붙일 것!
	- 지역(local) 변수에 까지도
		- 모든 회사가 이코딩 표준을 따르지는 않음
		- 그러나 우리의 코딩표준에는 따른다.
		
```cpp
Vector operator+(const Vector& rhs) const;// 이거 멤버변수 값 바뀌는 것 방지 함수
std::ostream& operator<<(const std::ostream& os , const Vector& rhs);

```
 
- const &를 사용하는 이유?
	-  불필요한 개체의 사본이 생기는 것을 방지
	-  멤버 변수가 바뀌는 것도 방지
	
	![[Pasted image 20250305154828.png]]

- 연산자 오버로딩에 const를 사용하지 않는 경우
	- 개체 복사가 없음
	- 연산자 여럿을 연결해서 쓸 수 있음

- 제한 사항
1. 오버로딩된 연산자는 최소한 하나의 사용자정의 형을 가져야 한다.
```cpp
Vector operator+(const Vector & rhs) const;	
```
	
1. 오버로딩된 연산자는 피연산자 수를 동일하게 유지해야 함.

![[스크린샷 2025-03-05 오후 4.14.06.png]]

### 결론

멤버가 아닌 함수를 이용한 연산자 오버로딩은 가능하다.
friend 키워드를 사용한다.

### 연산자 오버로딩을 남용하지 말 것
직관적이지 않은 상황에서는 함수를 쓰는 것이 더 나을 수도 있다.

### 대입(assignment) 연산자
 -  operator=
 - 이 연산자가 하는 일은?
 - 복사 생성자와 거의 동일
	 - 그러나 대입 연산자는 메모리를 해제해 줄 필요가 있을 수도...
	 -  복사 생성자를 구현했다면 대입 연산자도 구현해야 된다.

### 암시적 operator=
- operator= 구현이 안 되어 있으면 컴파일러가 operator= 연산자를 자동으로 만들어 줌

![[Pasted image 20250309163515.png]]
깊은 복사 VS 얕은 복사?
 깊은 복사이다!